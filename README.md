# Calculator

## 🗒︎목차
1. [소개](#-소개)
2. [개발환경 및 라이브러리](#-개발환경-및-라이브러리)
3. [팀원](#-팀원)
4. [타임라인](#-타임라인)
5. [UML](#-uml)
6. [실행화면](#-실행-화면)
7. [트러블 슈팅 및 고민](#-트러블-슈팅-및-고민)
8. [참고링크](#-참고-링크)


## 👋 소개
[하모](https://github.com/lxodud)가 구현한 Calculator Step-1 입니다.

## 💻 개발환경 및 라이브러리
[![swift](https://img.shields.io/badge/swift-5.6-orange)]()
[![xcode](https://img.shields.io/badge/Xcode-13.4.1-blue)]()


## 🧑 팀원
|<img src="https://i.imgur.com/ydRkDFq.jpg" width=200>|
|:--:|
|[하모](https://github.com/lxodud)|
  

## 🕖 타임라인

STEP-1: 2022.09.19 ~ 

## 🗺 UML


![제목 없는 다이어그램 (1)](https://user-images.githubusercontent.com/85005933/191208106-a6c61fca-9184-4db0-8525-20ee4a382677.jpg)



## 💻 실행 화면

## 🎯 트러블 슈팅 및 고민
### Step - 1 

#### 1. struct vs class에 대해 고민하였습니다.

먼저 Node가 값타입일 경우 인스턴스가 계속 복사되기때문에 LinkedList클래스에서 Node를 다룰 때 복사된 값에 작업을 하게되기 때문에 참조 타입으로 선언해 주어야 한다고 판단하였습니다.
추가적으로 Node를 Struct로 만들었을 내부에 자기 자신의 타입인 프로퍼티를 소유해야 하는데 값 타입이라 런타임에서 에러가 발생하였습니다. 따라서 Node는 Class로 선언하는 것이 맞다고 판단하였습니다.

LinkedList와 CalculatorItemQueue의 경우 값 타입을 사용해도 문제되는 부분이 없다고 생각하여 애플의 권장사항인 struct를 사용하게 되었습니다. 그리고 bringQueue()를 이용하여 LinkedList 인스턴스를 호출할 때 복사하여 전달해주기 때문에 원본값을 보존할 수 있다고 생각하였습니다.

#### 2. queue의 요소를 저장할 때 두 가지 자료구조에 대해서 고민하였습니다.
Array의 장단점
원하는 요소에 접근이 빠르다는 장점이 있습니다.
삭제나 삽입을 할 때 배열의 크기에 따라 복잡도가 올라갑니다.
Linked list의 장단점
삭제나 삽입을 할 때 해당 연결을 끊고 뒤의 요소에 주소값을 이어주면 되어 복잡도가 낮습니다.
원하는 요소에 접근할 때 처음부터 순차적으로 접근하여야해서 비효율적입니다.
값과, 다음 요소에 대한 정보를 가지고 있어야 하므로 메모리효율도 좋지않다고 생각됩니다.
두 방법의 장단점을 비교해보았을 때 큐를 구현할 때 원하는 위치의 값에 접근할 필요가 없는 없고 앞에 있는 요소만 꺼내와야 하기 때문에 값 빼낼 때 효율적인 Linked list를 사용하게 되었습니다.

    
## 📚 참고 링크

