## iOS 커리어 스타터 캠프

### 계산기 프로젝트 저장소

### UML
![Untitled (1)](https://user-images.githubusercontent.com/102569735/168732743-61f452f1-0bf0-44c1-9311-90c59a8d754a.jpg)

## Step01
+ 숫자와 연산기호를 저장하는 큐를 구현(Array를 통해 구현)

### 배운 점
+ Queue
  + FIFO(First In First Out)을 준수해야 한다.
  + 스택과는 반대되는 개념이다.

+ dequeue의 시간 복잡도
  + removeFirst를 통해 첫 번째 들어간 item을 반환할 경우 시간 복잡도는 O(n)이다.
  + head에 배열의 index를 저장해 head를 이동시키는 방식을 사용할 경우 시간 복잡도는 O(1)이 된다. 

+ 단방향 연결리스트
  + 연속되지 않은 메모리에 저장된 데이터들을 연결시켜 놓은 것이다.
  + 배열의 단점을 보완(마지막 index가 아닌 element를 삭제하거나 삽입할 경우 오버헤드가 발생한다.)
  + element를 저장하는 공간에 추가적으로 다음 데이터의 주소를 저장하는 공간을 가지고 있다.
주소를 저장하는 별도의 공간이 필요하기 때문에 저장 공간의 효율이 좋지 않다. 
  + 중간에 data를 삽입 삭제할 때 오버헤드가 발생하지 않는다.
  + 데이터를 접근하는데 있어 다음 데이터의 주소만 알고 있기 때문에 index를 통해 데이터의 접근하는 것 보다 속도가 느리다.
  + 배열의 append를 하기 위해서는 가장 마지막 node의 연결이 없는지를 확인해야 한다.
  + 중간에 있는 데이터를 추가하거나 삭제하기 위해서는 이전 노드에 저장된 주소를 변경시켜주어야 한다.

### 고민한 점
+ Step01에서 큐를 구현할 때 연결리스트를 사용하는 방법이 정말 좋은 방법인지 고민
단방향 연결리스트의 장점이 중간에 있는 data를 삽입 삭제할 때 오버헤드가 발생하지 않는다고 하는데 일반적인 큐 같은 경우 FIFO를 준수한다. 따라서 과연 중간에 있는 값을 삽입 삭제할 경우가 필요한 장점인지 고민이 된다. 장점을 활용하는 경우가 없다면 메모리 손해만 있을 것 같다.
우선순위 큐같이 우선 순위가 정해진 data를 먼저 가져올 때는 연결리스트 사용을 고려해 볼 것 같다.

### 수정 사항
+ 배열 같은 경우 복수형 네이밍을 사용한다.


## Step02

### 배운 점
+ 고차함수
  + input 타입이 함수 or output 타입이 함수인 함수를 말한다.
  + map : 기존 배열의 아이템을 개발자가 직접 매핑을 통해 새로운 배열을 만드는 함수이다.
  + filter : 기존 배열에서 조건이 참인 element를 뽑아 새로운 배열을 만든다.
  + reduce : 기존 배열의 아이템을 클로저가 제공하는 방식으로 결합해 최종 값을 반환한다.
  + forEach : 배열의 element를 이용해 특정 작업을 실행한다.
  + compactMap : 배열 내부에 있는 element타입이 옵셔널 타입일 경우 옵셔널 바인딩을 통해 새로운 배열을 만드는 함수이다.
```swift=
// reduce
var numsArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 축약형
var sum = numsArray.reduce(0) { $0 + $1 }

// 정식
var sum2 = numsArray.reduce(0) { (total, num) in
    return total + num
}

print(sum) // 55
print(sum2) // 55

// compactMap
var optionalInt: [Int?] = [1, nil, 2, nil, 3]

var onlyNum = optionalInt.compactMap { $0 }

print(onlyNum)

/*
[1, 2, 3]
*/
```
