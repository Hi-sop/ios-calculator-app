#  계산기 프로젝트
## 🧮 프로젝트 소개
- 두개의 큐 타입을 활용하여서 사칙연산을 수행하는 계산기

## 📍 목차
#### 1. [팀원](#🧑🏻‍💻-1-팀원)
#### 2. [순서도](#🔖-2-순서도)
#### 3. [타임라인](#⏱-3-타임라인)
#### 4. [실행 화면(기능 설명)](#💻-4-실행-화면기능-설명)
#### 5. [TDD](#🎯-5-TDD(테스트-코드-작성-과정))
#### 6. [트러블 슈팅](#🚀-5-트러블-슈팅)
#### 7. [참고 링크](#📎-6-참고-링크)

## 🧑🏻‍💻 1. 팀원
|미니|
|:----:|
|<img width="180px" img style="border: 2px solid lightgray; border-radius: 90px;-moz-border-radius: 90px;-khtml-border-radius: 90px;-webkit-border-radius: 90px;" src="https://i.imgur.com/ikEGO8k.jpg">|
| <a href="https://github.com/leegyoungmin"> <center>*@leegyoungmin*</center></a>|

## 🔖 2. 순서도
### Class Diagram
![ClassDiagram](https://i.imgur.com/fytj1rk.jpg)

## ⏱ 3. 타임라인
<!-- : 시간 순으로 프로젝트의 주요 진행 척도를 표시 -->
- **2022.09.19**
    - 프로젝트 초기 설정
    - 큐 타입에 대한 학습

- **2022.09.20**
    - 테스트 코드 작성
    - 큐 타입 구현
    - PR 발송

- **2022.09.21**
    - 리뷰에 따른 리팩토링 진행
    - 테스트 코드 리팩토링


## 💻 4. 실행 화면(기능 설명)
### 📌 STEP 1
- Queue 자료 구조에 대한 테스트 코드 작성 및 테스트 결과

    ![TestResult](https://i.imgur.com/qraEuJF.png)
    
    Queue 타입 내 구현된 프로퍼티 및 메서드에 대한 테스트를 수행하였습니다.
    테스트 수행 결과 모두 통과하였습니다.
- Queue 타입에 대한 Coverage
    ![Coverage](https://i.imgur.com/34UHCWG.png)

### 📌 STEP 2

## 🎯 5. TDD(테스트 코드 작성 과정)
### 📌 STEP 1
- 리팩토링 전
    - 처음 TDD를 수행하기 위해서 실패하는 테스트를 작성 후, 코드를 작성하였습니다.
    - 로직 작성 후, 실패하는 부분에 대해서 고민을 하게 되었습니다.
    - 저의 테스트가 지속적으로 실패하게 된 이유는, 비즈니스 로직을 잘못 작성한 부분과 테스트 동작이 실패 가능한 테스트 코드였다는 것입니다.
    - 테스트 코드가 실패가능하게 작성되었다면, 비즈니스 로직이 잘 작성되고, 잘 동작하여도 실패하는 테스트가 되기 때문에 조심해야 한다는 사실을 몸소 느끼게 되었습니다.

- 리팩토링 후 (리뷰 후 리팩토링)
    - 테스트 코드에 대해서 많은 부분에서 공부가 부족하다고 생각하여서, TDD와 테스트 코드를 공부 후 다시 작성할 수 있도록 하였습니다.
    - 테스트 코드는 명세서의 역할과 동시에 어떤 것을 테스트 하고 싶은지를 명확하게 정의 해야 한다는 생각을 하게 되었습니다. 그래서 아래와 같이 표를 정리하고, 테스트 코드를 작성할 수 있도록 하였습니다.
    
        | 목적 |
        | -------- |
        | 테스트 하고 싶은 것 : 큐가 FIFO의 동작을 잘 수행하는지 |
        | 테스트 코드의 역할 : 명세서 + 동작확인 → 하나의 테스트 코드에서 한 가지의 메서드 및 프로퍼티에 대해서 검사한다.|

        | 구분 | 설명 | 테스트 코드 로직 | 메서드 및 프로퍼티 |
        |:---|:---|:---|:---|
		| 1 | 빈 큐를 생성할 수 있는지에 대해서 테스트 | 테스트 코드 내에서 큐의 생성자의 인자를 주지 않고 초기화 후 비어있는지 확인 | init + isEmpty |
		| 2 | 배열을 통해서 비어있지 않는 큐를 생성할 수 잇는지 테스트 | 테스트 코드 내에서 배열을 생성자의 인자로 주어서 초기화 후 비어있지 않은지 확인 | init + isEmpty |
		| 3 | enqueue의 과정을 통해서 값이 정확하게 들어가지는 테스트 | 테스트 코드 내에서 enqueue를 수행 후 제일 처음 나오게 될 값이 추가한 요소의 값과 동일한지 확인 | enqueue + front |
		| 4 | 여러번의 enqueue의 과정을 한 후, 큐의 요소의 개수와 동일한지 테스트 | 테스트 코드 내에서 반복적으로 enqueue를 수행한 후 count 변수가 동일한지 확인 | enqueue + count |
		| 5 | dequeue를 하면 처음 들어간 값이 추출되는지 테스트 | 테스트 코드 내에서 enqueue를 수행 후 dequeue를 통해서 추출되는 값이 동일한지 확인 | enqueue + dequeue |
        
    - 위와 같은 표로 작성하면서, `Queue`의 명확한 동작을 확인하기 위해서 한가지의 동작만을 테스트 하는 것에는 부족함이 있다고 판단하여서, 기본적인 동작 후, 추가적 동작에 대해서 테스트 할 수 있도록 하였습니다.
### 📌 STEP 2

## 🚀 6. 트러블 슈팅
### 📌 STEP 1
- Generic타입과 Protocol 타입
    ```swift
    protocol CalculateItem { }

    extension Int: CalculateItem { }
    extension Double: CalculateItem { }

    struct CalculatorItemQueue<Element: CalculateItem> {
        var inputStack: [Element] = []
        var outputStack: [Element] = []
        ...
    }

    ```
    - 처음에는 `CalculateItem`타입의 리스트 타입을 통해서 구현하였습니다.
    - 하지만, 테스트코드를 작성시 `Equtable` 프로토콜을 채택한 타입으로만 `XCAssert` 메서드를 활용할 수 있었습니다.
    - 그래서 제네릭 타입을 활용하고, `Equtable` 프로토콜을 이미 채택하고 있는 `Int`,`Double` 타입을 확장하여서 제네릭의 타입으로 지정할 수 있도록 하였습니다.
    
- LinkedList vs Double Stack
    - Swift에서 Queue를 구성하기 위해서 다양한 방법이 있는 것을 공부하였습니다.
    - 단순 배열을 통하여 구현하였을 경우, `removeFirst`메서드를 활용하여야 했습니다. `removeFirst`의 시간 복잡도는 O(n)의 복잡도를 가지게 됩니다. 그렇기 때문에 많은 데이터가 들어왔을 경우에는 성능적인 측면에서 부족할 수 있다고 생각하였습니다.
    - Linked List를 통하여 구현하였을 경우, 일반 배열을 활용하는 것보다는 deqeue 메서드에서 복잡도가 O(1)의 복잡도로 낮아지는 것을 확인할 수 있습니다. 하지만, 연결 리스트를 활용할 때에는 값,이전 노드의 참조, 다음노드의 참조의 값을 가지고 있어야 하기 때문에 메모리 소모가 크다고 판단하였습니다.
    - Double Stack을 활용하여서 구현하였을 경우에는 단순 배열에서 겪는 문제점과 연결 리스트에서의 단점을 가지고 있지 않기 때문에 이를 통해서 구현하였습니다.

### 📌 STEP 2
### 📌 STEP 3


## 📎 7. 참고 링크
- [Queue 데이터 타입 구현](https://woongsios.tistory.com/222)
