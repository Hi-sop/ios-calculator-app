## iOS 커리어 스타터 캠프

### 계산기 프로젝트 저장소

> 프로젝트 기간 2022/05/16 ~ 2022/05/27  
> 팀원: [@sookoong](https://github.com/Jeon-Minsu) / 리뷰어: [@찰리](https://github.com/kcharliek)

# 목차
- [프로젝트 소개](#프로젝트-소개)
- [키워드](#키워드)

- [그라운드 룰](#그라운드-룰)
    - [활동시간](###시간)
    - [예외사항](##예외사항)
    - [의사소통 방법](##의사소통-방법)
    - [코딩 컨벤션](##코딩-컨벤션)

- [STEP 0](#STEP-0)
    - [고민한점](#고민한점)
    - [배운 개념](#배운개념)
- [STEP 1](#STEP-1)
    - [고민한점](#고민한점)
    - [배운개념](#배운개념)
- [STEP 2](#STEP-2)
    - [고민한점](#고민한점)
    - [배운개념](##배운개념)
- [STEP 3](#STEP-3)
    - [고민한점](#고민한점)
    - [배운개념](##배운개념)

# 프로젝트 소개
- 계산기 어플리케이션


# 개발환경 및 라이브러리
[![swift](https://img.shields.io/badge/swift-5.6-orange)]()
[![xcode](https://img.shields.io/badge/Xcode-13.3.1-blue)]()

# 키워드
- `queue`, `array`, `linked-list`, `double-stack`
- `UML`, `TDD`
- `enqueue`, `dequeue`, `peek`, `isEmpty`
- `clear`, `isFull`, `count`
- `generics`

# 그라운드 룰

### 시간

[프로젝트에 집중하는 시간]

- 09 : 00 ~ 22 : 00

[식사 시간]

- 점심 12 : 30 ~ 13 : 30
- 저녁 18 : 00 ~ 19 : 00

[연락이 어려운 시간]

- 수꿍 : 00 : 00 ~ 01 : 00

[휴일]

- 수꿍 : 주말

### 규칙

[커밋]

- 최소기능 단위 commit
- 카르마 스타일 따르기 ( 한글로 작성 )
- `feat` = 주로 사용자에게 새로운 기능이 추가되는 경우
- `fix` = 사용자가 사용하는 부분에서 bug가 수정되는 경우
- `docs` = 문서에 변경 사항이 있는 경우
- `style` = 세미콜론을 까먹어서 추가하는 것 같이 형식적인 부분을 다루는 경우 (코드의 변화가 생산적인 것이 아닌 경우)
- `refactor` = production code를 수정하는 경우 (변수의 네이밍을 수정하는 경우)
- `test` = 테스트 코드를 수정하거나, 추가하는 경우 (코드의 변화가 생산적인 것이 아닌 경우)

[컨벤션]

- Swift API Design Guidelines
- Swift Language Guide
- ios - Human Interface Guidelines

[커뮤니케이션]

- 디스코드 회의실
- 디스코드 다이렉트 메시지

# 핵심경험

# [STEP 1]

## UML
![calculator_UML](https://user-images.githubusercontent.com/99063327/168565413-a98d1400-f9e4-45bc-946b-7edfa04e803a.jpg)


## 고민한점 
### 1. Queue 생성 방법


- `swift`에서는 `queue`가 따로 구현되어 있지 않아 직접 만들어야 된다는 알게 되어, 처음에는 단순히 배열을 하나 생성하여, 선입선출이 될 수 있게 구현만 하면 되는 줄 알았습니다. 하지만, `queue`에 대하여 조사해본 결과, 생성 방법이 다양하게 존재하며, 각각의 방법에 따라 시간 복잡도가 상이함을 발견하였고, 이에 서로를 비교하여 최선의 방법을 찾을 필요성을 느꼈습니다. 
<br/>

> ### (1) 단순 배열
>- 장점 : 빈 공간에 요소를 추가할 시 빠르게 작동합니다. `enqueue` 메서드 구현시 `append`를 사용하여 시간복잡도가 `O(1)`에 해당합니다.
>- 단점 : 배열의 메모리는 기본적으로 고정되어 있습니다. 하지만, `enqueue` 과정이 빈번하게 발생하여 기존의 메모리를 초과하여 요소를 추가하고자 할 때, 메모리를 늘리는 과정 속에서 배열의 메모리를 n번 반복하여 할당해야 되므로 공간복잡도가 `O(n)`이 됩니다. `dequeue` 메서드 구현시 `removeFirst`를 사용하면, 첫번째 요소를 제거한 이후, 나머지 요소들의 순서또한 수정하는 작업이 이루어지게 되어 시간복잡도가 `O(n)`에 해당합니다.
<br/>


> ### (2) 연결 리스트
> - 장점 : `enqueue` 메서드도 O(1)로 빠르게 이루어짐과 동시에 배열의 단점이었던 `dequeue` 메서드의 수행속도가 `O(1)` 로 빠릅니다. 이는 연결리스트는 노드 형태로 이루어져 요소가 제거되어도 나머지 요소들을 재정렬하지 않아도 되기 때문입니다.
> - 단점 : 각각의 노드가 데이터와 참조하는 주소로 이루어져 있기 때문에 연결리스트를 추가할 때 수행하는 동적할당이 상대적으로 큰 메모리를 소모합니다. 이는 공간 복잡도를 크게 하며, 메모리 접근 시간도 더디게 합니다.  
<br/>

> ### (3) 더블 스택
> - 장점 1 : 두 개의 스택으로 큐를 구현하여 배열의 마지막 요소를 제거하는 연산은 재정렬이 필요하지 않으므로 수행속도가 빠르다. 이를 더 자세히 살펴보면, `enqueue` 메서드는 `append`를 사용하여 시간복잡도가 `O(1)`에 해당하고, `enqueueStack`의 요소를 반전시키는 `reversed` 기능의 시간복잡도가 `O(1)`에 해당하며, `dequeue` 메서드는 `popLast`를 사용하여 시간복잡도가 `O(1)`에 해당한다.
> - 장점 2: 더블스택으로 구현한 큐는 `Array`이기 때문에 요소가 모두 나란히 존재하여 각각의 주소를 참조하기에 요소들이 산개하여 존재하는 연결 리스트보다 공간복잡도가 낮으며, 메모리 접근 속도가 빠르다.
<br/>

- 위의 방법들을 비교해본 결과, 큐를 더블 스택 구조로 구현할 시, 다른 방법들보다 시간복잡도와 공간복잡도 면에서 강점을 갖고 있다고 판단하여, 이번 프로젝트에서 큐를 더블 스택 구조로 구성하였습니다.
<br/>

### 2. Queue 기능 구현

- 조사해본 바에 따르면 `Queue`는 다음의 최소 기능을 구현해야 한다고 이해하였습니다.
    
    1) `enqueue` : 큐의 맨 뒤에 새로운 요소를 추가
    
    2) `dequeue` : 큐의 맨 첫 번째 요소를 제거한 뒤 반환
    
    3) `peek` : 큐의 첫 번째 요소를 반환하되, 제거하지는 않음
    
    4) `isEmpty` : 큐가 비어있으면 `true`, 그렇지 않으면 `false` 반환
    
- 그리고, 기본적으로는 위의 기능에 추가하여 다음의 기능들을 필요로 한다는 사실을 발견하였습니다.
    
    1) `clear` : 큐를 재설정해 빈 상태가 되게 함
    
    2) `count` : 큐에 있는 요소의 수를 반환
    
    3) `isFull` : 큐가 꽉 차있으면 `true` 반환 / 그렇지 않으면 `false` 반환
<br/>

- 물론, 위의 메서드 이외에도 큐를 위한 추가적인 메서드를 구현할 수 있지만, 현재는 계산기 프로젝트임에 초점을 맞추어, 최소 기능인 `enqueue`, `dequeue`, `peek`, `isEmpty`에 더하여 큐의 모든 값을 `reset`해주는 `clear` 메서드를 추가하여 계산기 기능 구현을 위한 큐를 생성해보았습니다.
<br/>


## 의문점

### 1. TDD로 인한 접근 제어 설정 고민

- 이번 프로젝트를 통하여 `UML`과 `TDD`를 처음으로 진행하고 있어, 아직은 이를 원활히 사용하지 못하고 어려움을 겪고 있습니다.

- 그러던 도중, `CalculatorItemQueue` 구조체 안에 있는 프로퍼티인 `enqueueStack`과 `dequeueStack`을 `private`으로 접근 제어를 하려고 하였으나, `TDD`를 진행하면서, test_enqueue_enqueueStack에_100개의_실수가_순서대로_들어가는지를 테스트하던 중, “ **let** result = sut.enqueueStack “ 코드로 인하여 `private` 수준으로 접근 제어를 할 수 없어, 현재 `private(set)` 수준으로 은닉화를 진행하였습니다.

- `private`으로 충분히 설정할 수 있을 것 같다고 생각하였는데, 테스트 코드로 인하여 `private(set)`으로 설정한 작업은 제 생각에는 테스트 코드에 너무 몰입한 결과가 아닐까 우려가 됩니다. 이에, 테스트 코드를 무시하고 `private`으로 접근 제어를 하는 것이 옳은 방법인지 확신이 들지 않아 질문드립니다.
<br/>

### 2. TDD와 제너릭 고민

- `CalculatorItemQueue`는 숫자 이외에 사칙연산에 사용되는 연산자 또한 큐에 들어가야 하지 않을까 생각하여 코드의 확장성 및 유지보수에 용이한 제너릭을 사용하였습니다.
- `TDD`를 통해서 숫자가 들어오는 상황들은 제너릭 타입을 `Double`로 설정하여 테스트를 진행해보았습니다.
    
    ```swift
    class CalculatorItemQueueTests: XCTestCase {
        var sut: CalculatorItemQueue<Double>!
        
        override func setUpWithError() throws {
            try super.setUpWithError()
            sut = CalculatorItemQueue<Double>()
        }
    
        override func tearDownWithError() throws {
            try super.setUpWithError()
            sut = nil
        }
            ...
    }
    ```
    
- 하지만, 만약 사칙연산의 연산자들이 들어올 때는 이를 `character`나 `string`으로 제너릭 타입을 바꿔야함이 예상되는데, 그렇다면 기존에 `Double`로 설정한 테스트 코드는 작동이 실패할 것으로 생각됩니다.
- 이러한 별개의 상황에서 하나의 `sut`로는 구현이 불가능한 것인지, 만약 그렇다면 기존의 `sut` 프로퍼티 아래에 “var sut2: CalculatorItemQueue<String>!”과 같이 새로운 프로퍼티를 작성하여 각각의 상황에 맞게 사용하면 되는 것인지 궁금합니다.
<br/>

## 배운개념
- `queue`, `array`, `linked-list`, `double-stack`
- `UML`, `TDD`
- `enqueue`, `dequeue`, `peek`, `isEmpty`
- `clear`, `isFull`, `count`
- `generics`

# [STEP 2]

## 고민한점 

## 의문점

## 배운개념


# [STEP 3]

## 고민한점 

## 의문점

## 배운개념
